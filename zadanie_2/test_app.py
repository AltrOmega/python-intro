import app as a
import unittest



# Ive included old tests before adding implementations, and after adding em.
# The old ones didnt have type checking tho so keep it in mind.
# I have also added the coverage output, which looks identical to just running the unit tests...
# I tried doing a coverage report but its empty.

# What is not empty is the htmlcov generated by coverage command, but in addition there
# are screenshots of the generated website, and the singular coverage fail wchich is...
'''
if __name__ == '__main__':
    unittest.main()
'''
# for some reason. I dont get why it test coverage in the test file itself but i guess it
# probably just does no get its a unit test only file





class TestApp(unittest.TestCase):

    # Ugh i mean the setUp function is very forced here.
    # There is no need to have it in such a small script if you ask me,
    # as it will just make it harder to read with no good tradeoff...
    # It is required still. So here it goes.
    def setUp(self):
        ### What is tested
        # all lowercase, all uppercase except country code, nothing in particular
        self.valid_emails = ["abc@def.com", "XYZ@XYZ.pl", "foo@bar.eu"]
        # no @, double clearly invalid @@, invalid country code
        self.invalid_emails = ["abc.com", "Xyz@@ballyn.com", "a@a.1"]
        # as the name of variable says
        self.non_string_inputs = [123, None]

        # a singular @, lack of country code, lack of username, emailname size of two, double @@ in a more valid looking format
        self.edge_cases_to_fail = ["@", "user@.", ".@domain", "@.", "user@domain@com"]
        
        # valid inputs greater than 0
        self.square_valid_inputs = [(5, 25), (0, 0), (2.5, 6.25), (1.1, 1.21)]
        # Does it throw when given str instead of int
        self.square_type_error_inputs = ["5"]
        # Does it throw when given int < 0
        self.square_value_error_inputs = [-1]
        
        # If those pass, nothing much more specific.
        # Well i guess it also tests if passing
        # variable amout of lists work.
        self.filter_test_cases = [
            ([1, 2, 3, 4, 5], [1, 3, 5], None, [2, 4]),
            ([1, 2, 3], [], None, [1, 2, 3]),
            ([1, 2, 3], [1], [2], [3]),
            ([], [1, 2], None, []),
            ([1, 2, 3, 1, 2, 3], [1], [3], [2, 2])
        ]
        
        # Nothing speciall. Testing if all those are palidromes.
        self.palindromes = ["racecar", "madam", "", "a"]
        # Nothing speciall again all. Testing if those are NOT palidromes.
        self.non_palindromes = ["hello", "world", "abcde"]
        
        # as the var names say
        # those should True
        self.even_numbers = [2, 0, -4, 100]
        # those should not
        self.odd_numbers = [1, -3, 99]
        # those should throw
        self.non_integer_inputs = [2.5, "2"]



    def test_isOkEmailAddr(self):
        for email in self.valid_emails:
            self.assertTrue(a.isOkEmailAddr(email))
            
        for email in self.invalid_emails:
            self.assertFalse(a.isOkEmailAddr(email))
        
        for input_value in self.non_string_inputs:
            with self.assertRaises(TypeError):
                a.isOkEmailAddr(input_value)

        for email in self.edge_cases_to_fail:
            self.assertFalse(a.isOkEmailAddr(email))
    


    def test_calcSquareArea(self):
        for input_val, expected in self.square_valid_inputs:
            if isinstance(input_val, float):
                self.assertAlmostEqual(a.calcSquareArea(input_val), expected)
            else:
                self.assertEqual(a.calcSquareArea(input_val), expected)
        
        for input_val in self.square_type_error_inputs:
            with self.assertRaises(TypeError):
                a.calcSquareArea(input_val)
                
        for input_val in self.square_value_error_inputs:
            with self.assertRaises(ValueError):
                a.calcSquareArea(input_val)
        


    def test_filterOutValues(self):
        for main_list, filter1, filter2, expected in self.filter_test_cases:
            if filter2 is None:
                result = a.filterOutValues(main_list, filter1)
            else:
                result = a.filterOutValues(main_list, filter1, filter2)
            self.assertEqual(result, expected)
        
        with self.assertRaises(TypeError):
            a.filterOutValues("not a list", [1, 2])
        


    def test_isPalindrome(self):
        for word in self.palindromes:
            self.assertTrue(a.isPalindrome(word))
        
        for word in self.non_palindromes:
            self.assertFalse(a.isPalindrome(word))
        
        with self.assertRaises(TypeError):
            a.isPalindrome(12321)
        


    def test_isEven(self):
        for num in self.even_numbers:
            self.assertTrue(a.isEven(num))
        
        for num in self.odd_numbers:
            self.assertFalse(a.isEven(num))
        
        for input_val in self.non_integer_inputs:
            with self.assertRaises(TypeError):
                a.isEven(input_val)



if __name__ == '__main__':
    unittest.main()
